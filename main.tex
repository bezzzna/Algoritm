\documentclass[12pt]{article}
\usepackage[utf8]{inputenc} 
\usepackage[english,russian]{babel} 
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{txfonts}
\usepackage{url}
\addbibresource{sources.bib}
\usepackage{mathdots}
\usepackage{listings}
\usepackage[classicReIm]{kpfonts}
\usepackage[pdftex]{graphicx}
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\bibliography{sources.bib}



\lstdefinestyle{C}{               
    numbers=left,
    numbersep=0pt,
    keepspaces=true,
    breaklines=true
}




\begin{document}
\begin{titlepage}


\[\] 


\noindent 

\noindent 

\begin{figure}
    \begin{center}
        \includegraphics[width=0.1\textwidth]{image1.png}
    \end{center}
\end{figure}
\thispagestyle{empty}

\begin{small}



\renewcommand{\baselinestretch}{2.0} % Полуторный интервал
\centerline{\large{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ}}
\centerline{\large{ФЕДЕРАЦИИ}}
\centerline{Федеральное государственное автономное образовательное учреждение}
\centerline{высшего образования}
\centerline{\textbf{«Дальневосточный федеральный университет»}}
\centerline{\textbf{(ДВФУ)}}

\noindent\rule{\textwidth}{4pt}


\centerline{\textbf{ИНСТИТУТ МАТЕМАТИКИ И КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ}}
\centerline{\textbf{Департамент математического и компьютерного моделирования}}

\vfill

\vfill

\centerline{\textbf{Реферат}}
\centerline{\textbf{о практическом задание по дисциплине АИСД}}
\centerline{«Алгоритм поиска D*Lite»}
\par\noindent\rule{\textwidth}{0.3pt}
\centerline{направление подготовки 09.03.03 «Прикладная информатика»}
\centerline{профиль «Прикладная информатика в компьютерном дизайне»}

\vfill

\vfill

\noindent
\begin{tabular}{p{0.56\textwidth} p{0.70\textwidth}}
 & Выполнил студент  \\
 &  гр. Б9121-09.03.03пикд \\
 & Безрукова Анастасия Леонидовна  \\
 & \parindent0pt \\
\end{tabular}

\vfill
\noindent
\begin{tabular}{p{0.56\textwidth} p{0.70\textwidth}}
 Реферат защищен:& Руководитель практики  \\
 С оценкой \hrulefill & Доцент ИМКТ А.С Кленин  \\
 
\end{tabular}

\noindent


\vfill

\centerline{г. Владивосток}
\centerline{2023}
\clearpage
\end{small}
\end{titlepage}
\newpage


\begin{center}
   \section*{Аннотация} 
\end{center}

Сейчас существует множество алгоритмов сжатия информации. Большинство из них широко известны, но есть и некоторые весьма эффективные, но, тем не менее, малоизвестные алгоритмы.

Прежде чем рассказывать об арифметическом кодировании, надо сказать пару слов об алгоритме Хаффмана. Этот метод эффективен, когда частоты появления символов пропорциональны \textbf{\textit{1/2${}^{n}$}}~(где n -- натуральное положительное число). Это утверждение становится очевидным, если вспомнить, что коды Хаффмана для каждого символа всегда состоят из целого числа бит. Рассмотрим ситуацию, когда частота появление символа равна 0,2, тогда оптимальный код для кодирования это символа должен иметь длину --\textbf{\textit{log${}_{2}$(0,2)=2,3}} бита. Понятно, что префиксный код Хаффмана не может иметь такую длину, т.е. в конечном итоге это приводит к ухудшению сжатия данных.Арифметическое кодирование предназначено для того, чтобы решить эту проблему. Основная идея заключается в том, чтобы присваивать коды не отдельным символам, а их последовательностям.\newpage

\begin{center}
   \section*{Постановка задачи} 
\end{center}

Основная задача состоит в том, чтобы изучить данный нам алгоритм арифметического кодиравания, а затем на основе изученного материала его реализовать.

\newpage

\begin{center}
    \section*{Авторы и история}
\end{center}

Базовые алгоритмы арифметического кодирования были разработаны независимо~Йорма Дж. Риссаненом~из~IBM Research~и Ричардом К. Паско, аспирантом~Стэнфордского университета; оба были опубликованы в мае 1976 года.

\newpage

\begin{center}
    \section*{Описание алгоритма}
\end{center}

\textbf{Арифметическое кодирование}~--- один из алгоритмов энтропийного сжатия.

В отличие от~алгоритма Хаффмана, не имеет жесткого постоянного соответствия входных символов~группам бит выходного потока. Это даёт алгоритму большую гибкость в представлении дробных частот встречаемости символов.

Как правило, превосходит алгоритм Хаффмана~по эффективности сжатия, позволяет сжимать данные с энтропией, меньшей 1 бита на кодируемый символ, но некоторые версии имеют патентные ограничения от компании IBM.

При арифметическом кодировании каждый символ кодируется нецелым числом бит, что эффективнее кода Хаффмана (теоретически, символу~\textbf{\textit{a}}~с вероятностью появления~\textbf{\textit{p(a)}}~допустимо ставить в соответствие код длины~$\mathrm{-}$ \textbf{\textit{log2p(a)}}, следовательно, при кодировании алгоритмом Хаффмана это достигается только с вероятностями, равными обратным степеням двойки).

Пpи арифметическом кодировании текст представляется вещественными числами в интервале от 0 до 1. По мере кодирования текста, отображающий его интервал уменьшается, а количество битов для его представления возрастает. Очередные символы текста сокращают величину интервала исходя из значений их вероятностей, определяемых моделью. Более вероятные символы делают это в меньшей степени, чем менее вероятные, и, следовательно, добавляют меньше битов к результату.

Заданное множество символов --- это, как правило, ASCII+. Для того, чтобы обеспечить остановку алгоритма распаковки вначале сжимаемого сообщения надо поставить его длину или ввести дополнительный символ-маркер конца сообщения.

\newpage 

\begin{center}
    \section*{Пример работы}
\end{center}

Перед началом работы кодера соответствующий кодируемому тексту исходный интервал составляет~\textbf{[0; 1).}

Алфавит кодируемого сообщения содержит следующие символы (буквы): $\mathrm{\{}$~\textbf{Р, А, Д, И, О, В, З}~$\mathrm{\}}$.

Определим количество (встречаемость, вероятность) каждого из символов алфавита в сообщении и назначим каждому из них интервал, пропорциональный его вероятности. С учетом того, что в кодируемом слове всего 10 букв, получим (см. Таблица 1).

\begin{tabular}{|p{1.5in}|p{0.9in}|p{0.6in}|} \hline 
\textit{Символ} & \textit{Вероятность} & \textit{Интервал} \\ \hline 
\textit{А} & \textit{0,1} & \textit{0 -- 0,1} \\ \hline 
\textit{Д} & \textit{0,1} & \textit{0,1 -- 0,2} \\ \hline 
\textit{В} & \textit{0,1} & \textit{0,2 -- 0,3} \\ \hline 
\textit{И} & \textit{0,3} & \textit{0,3 -- 0,6} \\ \hline 
\textit{З} & \textit{0,1} & \textit{0,6 -- 0,7} \\ \hline 
\textit{О} & \textit{0,1} & \textit{0,7 -- 0,8} \\ \hline 
\textit{Р} & \textit{0.2} & \textit{0,8 -- 1} \\ \hline 
\end{tabular}

Таблица \textit{1}

Располагать символы в таблице можно в любом порядке: по мере их появления в тексте, в алфавитном или по возрастанию вероятностей -- это совершенно не принципиально. Результат кодирования при этом будет разным, но эффект -- одинаковым.

Итак, перед началом кодирования исходный интервал составляет [0 -- 1).

После просмотра первого символа сообщения~\textbf{Р}~кодер сужает исходный интервал до нового - [0.8; 1), который модель выделяет этому символу. Таким образом, после кодирования первой буквы результат кодирования будет находиться в интервале чисел [0.8 - 1).

Следующим символом сообщения, поступающим в кодер, будет буква~\textbf{А}. Если бы эта буква была первой в кодируемом сообщении, ей был бы отведен интервал [0 - 0.1), но она следует за~\textbf{Р}~и поэтому кодируется новым~подынтервалом внутри уже выделенного для первой буквы, сужая его до величины [0.80 - 0.82). Другими словами, интервал [0 - 0.1), выделенный для буквы~\textbf{А}, располагается теперь внутри интервала, занимаемого предыдущим символом (начало и конец нового интервала определяются путем прибавления к началу предыдущего интервала произведения ширины предыдущего интервала на значения интервала, отведенные текущему символу). В результате получим новый рабочий интервал [0.80 - 0.82), т. к. предыдущий интервал имел ширину в 0.2 единицы, и одна десятая от него есть 0.02.

Следующему символу~\textbf{Д}~соответствует выделенный интервал [0.1 - 0.2), что применительно к уже имеющемуся рабочему интервалу [0.80 - 0.82) сужает его до величины [0.802 - 0.804).

Следующим символом, поступающим на вход кодера, будет буква~\textbf{И~}с выделенным для нее фиксированным интервалом [0,3 -- 0,6). Применительно к уже имеющемуся рабочему интервалу получим [0,8026 - 0,8032).

Продолжая в том же духе, имеем:

вначале [0,0 - 1,0)

после просмотра~\textbf{Р}~[0,8 - 1,0)

\textbf{А~}[0,80 - 0,82)

\textbf{Д}~[0,802 - 0,804)

\textbf{И}~[0,8026 - 0,8032)

\textbf{О}~[0,80302 - 0,80308)

\textbf{В}~[0,803032 - 0,803038)

\textbf{И}~[0,8030338 - 0,8030356)

\textbf{З}~[0,80303488 - 0,80303506)

\textbf{И~}[0,803034934 - 0,803034988)

\textbf{Р~}[0,8030349772 - 0,8030349880)

Результат кодирования: интервал [0,8030349772 -- 0,8030349880]. На самом деле, для однозначного декодирования теперь достаточно знать только одну границу интервала -- нижнюю или верхнюю, то есть результатом кодирования может служить начало конечного интервала - 0,8030349772. Если быть еще более точным, то любое число, заключенное~внутри~этого интервала, однозначно декодируется в исходное сообщение. К примеру, это можно проверить с числом 0,80303498, удовлетворяющим этим условиям. При этом последнее число имеет меньшее число десятичных разрядов, чем числа, соответствующие нижней и верхней границам интервала, и, следовательно может быть представлено меньшим числом двоичных разрядов.

\newpage

\begin{center}
    \section*{Описание реализации}
\end{center}

Реализация алгоритма состоит из 4 функций (\textbf{\textit{get\_number (), get\_code (), coding (), decoding ()}}), а также главной функции \textbf{\textit{main (), }}где, собственно, и вызываются функции.

Для начала через директиву \textbf{\textit{\#define}} объявим две глобальные переменные \textbf{\textit{M}} и \textbf{\textit{N}}, где переменная \textbf{\textit{М}} отвечает за длину сообщения (в нашем случае длина 100), и \textbf{\textit{N}} отвечает за количество символов в используемом нами словаре (в нашем случае 4).

\begin{lstlisting}[language=C,style=C]
    #include <iostream>
    #define M 100
    #define N 4
    using namespace std;

\end{lstlisting}

Далее определяем приватные переменные, присваиваем их классу \textbf{\textit{suanshu }}и определяем публичные функции для данного класса. Публичные функции нужны для того, чтобы мы могли иметь доступ к ним из любого места кода.

\begin{lstlisting}[language=C,style=C]
    class suanshu
    {
        int count, length;
        char number[N], n;
        long double chance[N], c;
        char code[M];
        long double High, Low, high, low, d;
    public:
        suanshu()
        {
            High = 0; Low = 0;
        }
	   void get_number();
	   void get_code();
	   void coding();
	   void decoding();
	   ~suanshu() {}
    };

\end{lstlisting}

\textbf{\textit{$\boldsymbol{\sim}$suanshu()}} --- Это функция деструктора, для очистки памяти.

Функция \textbf{\textit{get\_number ()}} отвечает за получение символов (\textbf{\textit{number [i]}}) и их вероятностей (\textbf{\textit{chance[i]}}), которые мы вводим.

\begin{lstlisting}[language=C,style=C]
    void suanshu::get_number()
    {
        cout << "enter the letter and it's chance:" << endl;
        int i = 0;
        for (; i < N; i++)
        {
            cin >> n >> c;
            number[i] = n;
            chance[i] = c;
        }
    if (i == 20) {
        cout << "the number is full." << endl;
    }
    count = i;
    }

\end{lstlisting}

Функция \textbf{\textit{get\_code ()}} выполняет ввод длины кодируемого сообщения, чтобы программа знала, когда ей остановиться. Так же эта функция получает на ввод сам код сообщения, которое нам нужно закодировать.

\begin{lstlisting}[language=C,style=C]
    void suanshu::get_code()
    {
        cout << "length:";
        cin >> length;
        while (length >= M)
        {
            cout << "length is too long, enter less:";
            cin >> length;
        }
        cout << "output code:";
        for (int i = 0; i < length; i++)
        {
            cin >> code[i];
        }
    }

\end{lstlisting}

Функция \textbf{\textit{coding ()}} выполняет само кодирование сообщения, которое мы ввели. Сначала она обрабатывает первый введённый нами символ, оценивает его подстрочный индекс (строка 5) и находит его верхнюю и нижнюю границы (строки 7,9).

\begin{lstlisting}[language=C,style=C]
    void suanshu::coding()
    {
        int i, j = 0;
        for (i = 0; i < count; i++)
            if (code[0] == number[i]) break;
        while (j < i)
            Low += chance[j++];
        d = chance[j];
        High = Low + d;

\end{lstlisting}

Затем рассматривается второй символ. Если он равен предыдущему, то нижнюю границу символа остаётся прежней и меняется только верхняя (строки 4--12). Так же пересчитывается вероятность. Иначе если второй символ другой, то меняется и нижняя и верхняя границы, так же меняется и вероятность (строки 14 -- 23). В этой же функции выводится результат кодирования, в нашем случае это нижняя граница (строка 27).

\begin{lstlisting}[language=C,style=C]
    for (i = 1; i < length; i++)
        for (j = 0; j < count; j++)
        {
            if (code[i] == number[j])
            {
                if (j == 0)
                {
                    low = Low;
                    high = Low + chance[j] * d;
                    High = high;
                    d *= chance[j];
                }
                else
                {
                    long double chance_l = 0.0;
                    for (int k = 0; k <= j - 1; k++)
                    chance_l += chance[k];
                    low = Low + d * chance_l;
                    high = Low + d * (chance_l + chance[j]);
                    Low = low;
                    High = high;
                    d *= chance[j];
                }
            }
            else continue;
        }
        cout << "the result is:" << Low << endl;
    }

\end{lstlisting}

Функция \textbf{\textit{decoding ()}} отвечает за декодирование нашего сообщения. В начале объявляем переменную типа char, которая отвечает за количество декодируемых символов (в нашем случае не больше 100).

\begin{lstlisting}[language=C,style=C]
    void suanshu::decoding()
    {   
        int i, j;
        char out[100];

\end{lstlisting}

Далее расшифровываем символы по одному, постоянно меняя интервал кодирования, исходя из полученного результата в предыдущей функции (нижней границы \textbf{\textit{Low}}).

\begin{lstlisting}[language=C,style=C]
        for (i = 0; i < length; i++)
        {
            long double m0 = 0.0;
            long double m1 = 0.0;
            for (j = 0; j < count; j++)
            {
                m0 = m1;
                m1 = m0 + chance[j];
                if ((Low >= m0) && (Low < m1))
                {
                    out[i] = number[j];
                    Low -= m0;
                    Low = Low / (chance[j]);
                    break;
                }
                continue;
            }
            cout << out[i];
        }
        cout << endl;
    }

\end{lstlisting}

Последняя главная функция \textbf{\textit{main ()}} отвечает за вызов всех функций.

\begin{lstlisting}[language=C,style=C]
    int main()
    {
        setlocale(LC_ALL, "Russian");
        suanshu a;
        a.get_number();
        a.get_code();
        a.coding();
        a.decoding();
        return 0;
    }

\end{lstlisting}
\newpage





\nocite{*}
\printbibliography



\end{document}

